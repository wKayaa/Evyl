"""
Exploit Orchestrator for Evyl Framework

Coordinates exploitation modules and manages the exploit execution flow.
"""

import asyncio
from typing import List, Dict, Any, Optional
from dataclasses import dataclass

from utils.logger import Logger
from modules.kubernetes.k8s_scanner import KubernetesScanner
from modules.cloud.aws_scanner import AWSScanner
from modules.cloud.gcp_scanner import GCPScanner
from modules.cloud.azure_scanner import AzureScanner
from modules.web.git_dumper import GitDumper
from modules.web.js_crawler import JSCrawler
from modules.web.config_scanner import ConfigScanner
from modules.web.laravel_scan import LaravelScanner
from modules.web.smtp_scanner import SMTPSecurityScanner

@dataclass
class ExploitResult:
    """Result from an exploitation attempt"""
    module: str
    target: str
    success: bool
    vulnerabilities: List[Dict[str, Any]]
    credentials: List[Dict[str, Any]]
    error: Optional[str] = None

class Exploiter:
    """Main exploit orchestrator"""
    
    def __init__(self, scanner):
        self.scanner = scanner
        self.logger = Logger()
        
        # Initialize modules
        self.modules = {
            'kubernetes': KubernetesScanner(),
            'aws': AWSScanner(),
            'gcp': GCPScanner(),
            'azure': AzureScanner(),
            'git': GitDumper(),
            'js': JSCrawler(),
            'config': ConfigScanner(),
            'laravel': LaravelScanner(),
            'smtp': SMTPSecurityScanner()
        }
    
    async def exploit_targets(self, targets: List[str], enabled_modules: List[str] = None) -> List[ExploitResult]:
        """Run exploitation against targets"""
        if enabled_modules is None:
            enabled_modules = list(self.modules.keys())
        
        results = []
        
        for target in targets:
            for module_name in enabled_modules:
                if module_name in self.modules:
                    try:
                        result = await self._run_module(module_name, target)
                        results.append(result)
                    except Exception as e:
                        self.logger.error(f"Module {module_name} failed on {target}: {e}")
                        results.append(ExploitResult(
                            module=module_name,
                            target=target,
                            success=False,
                            vulnerabilities=[],
                            credentials=[],
                            error=str(e)
                        ))
        
        return results
    
    async def _run_module(self, module_name: str, target: str) -> ExploitResult:
        """Run a specific module against a target"""
        module = self.modules[module_name]
        self.logger.debug(f"Running {module_name} module against {target}")
        
        try:
            result = await module.scan(target)
            return ExploitResult(
                module=module_name,
                target=target,
                success=True,
                vulnerabilities=result.get('vulnerabilities', []),
                credentials=result.get('credentials', [])
            )
        except Exception as e:
            raise e